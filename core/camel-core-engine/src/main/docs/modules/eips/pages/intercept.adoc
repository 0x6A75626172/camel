= Intercept

The intercept feature in Camel supports intercepting
xref:latest@manual:ROOT:exchange.adoc[Exchange]'s' while they are being routed.

== Interceptor kinds

Camel supports three kinds of interceptors:

* `intercept` that intercepts every processing step as they happen during routing
* `interceptFrom` that intercepts only the incoming step (i.e. xref:from-eip.adoc[from])
* `interceptSendToEndpoint` that intercepts only when an
xref:latest@manual:ROOT:exchange.adoc[Exchange] is about to be sent to the given xref:message-endpoint.adoc[endpoint].

=== Common features of the interceptors

All these interceptors support the following features:

* xref:latest@manual:ROOT:predicate.adoc[Predicate] using `when` to only trigger the interceptor in certain conditions
* `stop` forces stopping continue routing the Exchange and mark it as completed successful (it's actually the xref:stop-eip.adoc[Stop] EIP).
* `skip` when used with `interceptSendToEndpoint` will *skip* sending the message to the original intended endpoint.
* `afterUrl` when used with `interceptSendToEndpoint` allows to send
the message to an xref:message-endpoint.adoc[endpoint] afterwards.
* `interceptFrom` and `interceptSendToEndpoint` supports endpoint
URI pattern matching by: exact uri, wildcard, regular expression. See further below for more details.
* The intercepted endpoint uri is stored as message header with the key
`Exchange.INTERCEPTED_ENDPOINT`.

=== Using intercept

The `Intercept` is intercepting the xref:latest@manual:ROOT:exchange.adoc[Exchange]
on every processing steps during routing.

Given the following example:

[source,java]
-------------------------------------------------------------------------
// global interceptor for all routes
intercept().to("log:hello");

from("jms:queue:order")
  .to("bean:validateOrder")
  .to("bean:processOrder");
-------------------------------------------------------------------------

What happens is that the `Exchange` is intercepted
before each processing step, that means that it will be intercepted
before

* `.to("bean:validateOrder")`
* `.to("bean:processOrder")`

So in this example we intercept the `Exchange` twice.

The example is as follows in XML:

[source,xml]
----
<camelContext>

  <!-- global interceptor for all routes -->
  <intercept>
    <to uri="log:hello"/>
  </intercept>

  <route>
    <from uri="jms:queue:order"/>
    <to uri="bean:validateOrder"/>
    <to uri="bean:processOrder"/>
  </route>

</camelContext>
----

=== Controlling when to intercept using a predicate

If you only want to intercept "sometimes", then you can use a xref:latest@manual:ROOT:predicate.adoc[predicate].

For instance in the sample below we only intercept if the message body
contains the string word Hello:

[source,java]
----
intercept().when(body().contains("Hello")).to("mock:intercepted");

from("jms:queue:order")
  .to("bean:validateOrder")
  .to("bean:processOrder");
----

And in XML:

[source,xml]
----
<camelContext>

  <intercept>
      <when>
          <simple>${in.body} contains 'Hello'</simple>
      </when>
      <to uri="mock:intercepted"/>
  </intercept>

  <route>
    <from uri="jms:queue:order"/>
    <to uri="bean:validateOrder"/>
    <to uri="bean:processOrder"/>
  </route>

</camelContext>
----

=== Stop routing after being intercepted

It is also possible to stop continue routing after being intercepted.
Now suppose if the message body contains the word Test we want to log and stop, then we can do:

[source,java]
----
intercept().when(body().contains("Hello"))
  .to("mock:intercepted")
  .stop(); // stop continue routing

from("jms:queue:order")
  .to("bean:validateOrder")
  .to("bean:processOrder");
----

And in XML:

[source,xml]
----
<camelContext>

  <intercept>
      <when>
        <simple>${body} contains 'Test'</simple>
        <to uri="log:test"/>
        <stop/> <!-- stop continue routing -->
      </when>
  </intercept>

  <route>
    <from uri="jms:queue:order"/>
    <to uri="bean:validateOrder"/>
    <to uri="bean:processOrder"/>
  </route>

</camelContext>
----

== Using intercept from

The `interceptFrom` is for intercepting any incoming
Exchange, in any route (it intercepts all the xref:from-eip.adoc[from] EIPs)

This allows you to do some custom behavior for received Exchanges.
You can provide a specific uri for a given Endpoint then it only
applies for that particular route.

So lets start with the logging example. We want to log all the
incoming messages, so we use `interceptFrom` to route to the
xref:components::log-component.adoc[Log] component.

[source,java]
----
interceptFrom()
  .to("log:incoming");

from("jms:queue:order")
  .to("bean:validateOrder")
  .to("bean:processOrder");
----

And in XML:

[source,xml]
----
<camelContext>

  <intercept>
    <to uri="log:incoming"/>
  </intercept>

  <route>
    <from uri="jms:queue:order"/>
    <to uri="bean:validateOrder"/>
    <to uri="bean:processOrder"/>
  </route>

</camelContext>
----

If you want to only apply a specific endpoint, such as all jms endpoints,
you can do:

[source,java]
----
interceptFrom("jms*")
  .to("log:incoming");

from("jms:queue:order")
  .to("bean:validateOrder")
  .to("bean:processOrder");

from("file:inbox")
  .to("ftp:someserver/backup")
----

In this example then only messages from the JMS route is intercepted, because
we specified a pattern in the `interceptFrom` as `jms*` (uses a wildcard).

The pattern syntax is documented in more details later.

And in XML:

[source,xml]
----
<camelContext>

  <interceptFrom uri="jms*">
    <to uri="log:incoming"/>
  </intercept>

  <route>
    <from uri="jms:queue:order"/>
    <to uri="bean:validateOrder"/>
    <to uri="bean:processOrder"/>
  </route>
  <route>
    <from uri="file:inbox"/>
    <to uri="ftp:someserver/backup"/>
  </route>

</camelContext>
----


== Using intercept when sending to an endpoint

TODO: Continue HERE!!!!


Intercept send to endpoint is triggered when an
Exchange is being sent to the intercepted endpoint.
This allows you to route the Exchange to a
detour or do some custom processing before the
Exchange is sent to the original intended
destination. You can also skip sending to the intended destination. By
default Camel will send to the original intended destination after the
intercepted route completes. And as the regular intercept you can also
define an `when` Predicate so we only intercept if
the Predicate evaluates to *true*. This allows you
do a bit of filtering, to only intercept when certain criteria is
meet. And finally you can send the Exchange to an endpoint with the `afterUrl` option. You can use this to process the response from the original endpoint.

Let start with a simple example, where we want to intercept when an
Exchange is being sent to `mock:foo`:

And this time we add the Predicate so its only when
the message body is `Hello World` we intercept.

And to skip sending to the `mock:foo` endpoint we use the *`skip()` DSL
in the route at the end to instruct Camel to skip sending to the
original intended endpoint.

*Conditional skipping*

The combination of `skipSendToEndpoint` with a `when` predicate only occurs if the `when` predicate is matched, leading to more natural logic altogether.

[source,java]
-------------------------------------
interceptSendToEndpoint("mock:foo").skipSendToOriginalEndpoint()
    .when(simple("${body} == 'Hello World'")
    .to("log:intercepted");
-------------------------------------


[[Intercept-UsingfromSpringDSL.2]]
=== Using from Spring DSL

Intercept endpoint is of course also available using Spring DSL.

We start with the first example from above in Spring DSL:

And the 2nd. Notice how we can leverage the xref:components:languages:simple-language.adoc[Simple]
language for the Predicate:

And the 3rd with the `skip`, notice skip is set with the
`skipSendToOriginalEndpoint` attribute on the *interceptSendToEndpoint*
tag:

[source,xml]
--------------------------------------
<camelContext>
    <interceptSendToEndpoint uri="mock:foo" skipSendToOriginalEndpoint="true">
        <when><simple>${body} == 'Hello World'</simple></when>
        <to uri="log:intercepted"/>
    </interceptSendToEndpoint>

    <route>
        <from uri="jms:queue:order"/>
        <to uri="bean:validateOrder"/>
        <to uri="bean:handleOrder"/>
    </route>
</camelContext>
--------------------------------------

[[Intercept-InterceptSendToEndpoint-with-afterUrl]]
== InterceptSendToEndpoint with afterUrl

The interceptor allows to call an endpoint after the intercepted message has been sent to the original endpoint, which allows you to process the response from the original endpoint. For example to log the request/response from sending to all JMS endpoints you can do:

[source,java]
-------------------------------------
interceptSendToEndpoint("jms*").afterUrl("log:jms-reply")
    .to("log:jms-request");
-------------------------------------

And in XML DSL:

[source,xml]
--------------------------------------
<interceptSendToEndpoint uri="jms*" afterUrl="log:jms-reply">
    <to uri="log:jms-request"/>
</inteinterceptSendToEndpointcept>
--------------------------------------


[[Intercept-AdvancedusageofIntercept]]
== Advanced usage of Intercept

The `interceptFrom` and `interceptSendToEndpoint` supports endpoint URI
matching by the following rules in the given order:

* match by exact URI name. This is the sample we have seen above.
* match by wildcard
* match by regular expression.

The real endpoint that was intercepted is stored as uri in the message
IN header with the key `Exchange.INTERCEPTED_ENDPOINT`. +
 This allows you to get hold of this information, when you for instance
match by wildcard. Then you know the real endpoint that was intercepted
and can react accordingly.

[[Intercept-Matchbywildcard]]
=== Match by wildcard

Match by wildcard allows you to match a range of endpoint or all of a
given type. For instance use `uri="file:*"` will match all
File based endpoints.

[source,java]
-------------------------------------
intercept("jms:*").to("log:fromjms");
-------------------------------------

Wildcards is match that the text before the * is matched against the
given endpoint and if it also starts with the same characters its a
match. For instance you can do:

[source,java]
----------------------------------------------------------
intercept("file://order/inbox/*").to("log:newfileorders");
----------------------------------------------------------

To intercept any files received from the `order/inbox` folder.

[[Intercept-Matchbyregularexpression]]
=== Match by regular expression

Match by regular expression is just like match by wildcard but using
regex instead. So if we want to intercept incoming messages from gold
and silver JMS queues we can do:

[source,java]
-----------------------------------------------------------
intercept("jms:queue:(gold|silver)").to("seda:handleFast");
-----------------------------------------------------------

*About dynamic and static behavior of interceptFrom and
interceptSendToEndpoint*

The `interceptSendToEndpoint` is dynamic hence it will also trigger if a
dynamic URI is constructed that Camel was not aware of at startup
time. +
 The `interceptFrom` is not dynamic as it only intercepts input to
routes registered as routes in `CamelContext`. So if you dynamic
construct a `Consumer` using the Camel API and consumes an
Endpoint then the `interceptFrom` is not triggered.


